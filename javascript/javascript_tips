Define variables with 'var'

- var x = 0;
- var x = 0 , y = 1;

There are six basic types of values: Numbers, strings, booleans, objects,
functions, and undefined values.

In javascript, numbers are 64 bits. 52 bits are to store an integer, one
bit for sign, 11 bits to store the position of the fractional dot within the
number.


Define a string like that:

- var x = "Patch my boat with chewing gum.";
- var y = "Boo \n haha";

String can only be concatenated (+). It cannot be divided, multiplied or
substracted.

Not all operators are symbols, some are written as words. For example,
the typeof operator, which produces a string value naming the type of the value
you give it.

- typeof 4.5   <- returns 'Number'

Then there are values of the boolean type. There are only two of these:
true and false. Here is one way to produce a true value:

- 3 > 2

Strings can be compared in the same way:

- "Aardvark" < "Zoroaster"

The way strings are ordered is more or less alphabetic. More or less...
Uppercase letters are always 'less' than lowercase ones, so "Z" < "a" 

- "Itchy" != "Scratchy"

The && operator represents logical and. It is a binary operator, and its result
is only true if both of the values given to it are true.

- true && false

|| is the logical or, it is true if either of the values given to it is true:

- true || false

Most statements end with a semicolon (;). 

The word var is used to create a new variable. After var, the name of the
variable follows. Variable names can be almost every word, but they may not
include spaces. Digits can be part of variable names, catch22 is a valid name,
but the name must not start with one. The characters '$' and '_' can be used 
in names as if they were letters, so $_$ is a correct variable name.

A lot of the values provided by the standard environment have the 
type 'function'. A function is a piece of program wrapped in a value. 
Generally, this piece of program does something useful, which can be 
invoked using the function value that contains it.

Showing a dialog window is a side effect. A lot of functions are useful because
of the side effects they produce.

- alert(Math.max(2, 4 ));

When a function produces a value, it is said to return it. 

The standard environment provided by browsers contains a few more functions 
for popping up windows. You can ask the user an OK/Cancel question using 
confirm. This returns a boolean, true if the user presses 'OK', and false 
if he presses 'Cancel'.

- confirm("Shall we?");

prompt can be used to ask an 'open' question. The first argument is the 
question, the second one is the text that the user starts with. A line of 
text can be typed into the window, and the function will return 
this as a string.

- prompt("Tell us everything you know.", "");
- var theNumber = Number(prompt("Pick a number", ""));

The function Number converts a value to a number, which is needed in this case
because the result of prompt is a string value. There are similar functions 
called String and Boolean which convert values to those types.

while loop:

- while (currentNumber <= 12 ) {
    print(currentNumber);
    currentNumber = currentNumber + 2;
  }

for loop:

- for (var number = 0; number <= 12; number = number + 2 )
    show(number);

- ( Notice that there are no braces for one-liner )

Javascript naming convention for methods is the same as for Java.

In a few cases, such as the Number function, the first letter of a variable
is also capitalised. This was done to mark this function as a constructor.

The keyword if is not too different from the keyword while: It checks the 
condition it is given (between parentheses ), and executes the statement 
after it based on this condition. But it does this only once, so that the 
statement is executed zero or one time.

When a loop does not always have to go all the way through to its end, 
the break keyword can be useful.


There is also a similar value, null, whose meaning is 'this variable is 
defined, but it does not have a value'. The difference in meaning between 
undefined and null is mostly academic, and usually not very interesting. 
In practical programs, it is often necessary to check whether 
something 'has a value'. In these cases, the expression 
something == undefined may be used, because, even though they are not 
exactly the same value, null == undefined will produce true.

- All of these return true
- show(false == 0 );
- show("" == 0);
- show("5" == 5);

When comparing values that have different types, JavaScript uses a 
complicated and confusing set of rules. I am not going to try to explain 
them precisely, but in most cases it just tries to convert one of the values 
to the type of the other value. However, when null or undefined occur, it 
only produces true if both sides are null or undefined.


What if you want to test whether a variable refers to the value false? 
The rules for converting strings and numbers to boolean values state that 
0 and the empty string count as false, while all the other values count as true. 
Because of this, the expression variable == false is also true when variable 
refers to 0 or "". For cases like this, where you do not want any automatic 
type conversions to happen, there are two extra operators: === and !==. The 
first tests whether a value is precisely equal to the other, and the second 
tests whether it is not precisely equal.

- All these are false
- show(null === undefined );
- show(false === 0 );
- show("" === 0);
- show("5" === 5);

Values given as the condition in an if, while, or for statement do not have to 
be booleans. They will be automatically converted to booleans before they are 
checked. This means that the number 0, the empty string "", null, undefined, 
and of course false, will all count as false.

The fact that all other values are converted to true in this case makes 
it possible to leave out explicit comparisons in many situations. 
If a variable is known to contain either a string or null, one could check 
for this very simply...

- var maybeNull = null;
  
  if (maybeNull)
      print("maybeNull has a value");

Except in the case where the mystery code gives maybeNull the value "". 
An empty string is false, so nothing is printed. Depending on what you are 
trying to do, this might be wrong. It is often a good idea to add an 
explicit === null or === false in cases like this to prevent subtle mistakes. 
The same occurs with number values that might be 0.

This kind of text is called a comment. The rules are like this: '/*' starts
a comment that goes on until a '*/' is found. '//' starts another kind of 
comment, which goes on until the end of the line.

There are some other situations that cause automatic type conversions to 
happen. If you add a non-string value to a string, the value is automatically 
converted to a string before it is concatenated. If you multiply a number 
and a string, JavaScript tries to make a number out of the string.

All arithmetic operations on the value NaN result in NaN, which is why 
multiplying it by 5, as in the example, still gives a NaN value.

Also, and this can be disorienting at times, NaN == NaN equals false, 
checking whether a value is NaN can be done with the isNaN function. NaN is 
another (the last ) value that counts as false when converted to a boolean.

These automatic conversions can be very convenient, but they are also 
rather weird and error prone. Even though + and * are both arithmetic 
operators, they behave completely different in the example. In my own code, 
I use + to combine strings and non-strings a lot, but make it a point not to 
use * and the other numeric operators on string values. Converting a number 
to a string is always possible and straightforward, but converting a 
string to a number may not even work (as in the last line of the example ). 
We can use Number to explicitly convert the string to a number, making it 
clear that we might run the risk of getting a NaN value.

- show(Number("5") * 5);

When we discussed the boolean operators && and || earlier, 
I claimed they produced boolean values. This turns out to be a bit of an 
oversimplification. If you apply them to boolean values, they will indeed 
return booleans. But they can also be applied to other kinds of values, in 
which case they will return one of their arguments.

What || really does is this: It looks at the value to the left of it 
first. If converting this value to a boolean would produce true, it 
returns this left value, otherwise it returns the one on its right. 
Check for yourself that this does the correct thing when the arguments are 
booleans. Why does it work like that? It turns out this is very practical. 
Consider this example:

- var input = prompt("What is your name?", "Kilgore Trout");
  print("Well hello " + (input || "dear" ));

If the user presses 'Cancel' or closes the prompt dialog in some other 
way without giving a name, the variable input will hold the value null or "". 
Both of these would give false when converted to a boolean. 
The expression input || "dear" can in this case be read as 'the value of the 
variable input, or else the string "dear"'. It is an easy way to 
provide a 'fallback' value.

The && operator works similarly, but the other way around. When the value 
to its left is something that would give false when converted to a boolean, 
it returns that value, otherwise it returns the value on its right.

Another property of these two operators is that the expression to their 
right is only evaluated when necessary. In the case of true || X, 
no matter what X is, the result will be true, so X is never evaluated, 
and if it has side effects they never happen. The same goes for false && X.

- false || alert("I'm happening!");
- true || alert("Not me.");


The defining properties of pure functions are that they always return the same 
value when given the same arguments, and never have side effects. They take 
some arguments, return a value based on these arguments, and do not monkey 
around with anything else.

- function add(a, b ) {
      return a + b;
  }

The keyword function is always used when creating a new function. When it is 
followed by a variable name, the resulting function will be stored under this 
name. After the name comes a list of argument names, and then finally the 
body of the function.

The keyword return, followed by an expression, is used to determine the 
value the function returns. When control comes across a return statement, 
it immediately jumps out of the current function and gives the returned value 
to the code that called the function. A return statement without an 
expression after it will cause the function to return undefined.

A variable created inside a function exists only inside the function.

Pure functions have two very nice properties. They are easy to think about, 
and they are easy to re-use.

Functions with side effects do not have to contain a return statement. 
If no return statement is encountered, the function returns undefined.

The names of the arguments of a function are available as variables inside it. 
They will refer to the values of the arguments the function is being called 
with, and like normal variables created inside a function, they do not exist 
outside it. Aside from the top-level environment, there are smaller, local 
environments created by function calls. When looking up a variable inside a 
function, the local environment is checked first, and only if the variable 
does not exist there is it looked up in the top-level environment. This makes 
it possible for variables inside a function to 'shadow' top-level variables 
that have the same name.

However, and this is a subtle but extremely useful phenomenon, when a 
function is defined inside another function, its local environment will be 
based on the local environment that surrounds it instead of the top-level 
environment.

- var variable = "top-level";
  function parentFunction() {
      var variable = "local";

      function childFunction() {
              print(variable);
      }

      childFunction();

   }
   parentFunction();

People who have experience with other programming languages might 
expect that a block of code (between braces ) also produces a new local 
environment. Not in JavaScript.

-  var something = 1;
   {
      var something = 2;
      print("Inside: " + something);
   }
   print("Outside: " + something);



- var variable = "top-level";
  function parentFunction() {
      var variable = "local";

      function childFunction() {
              print(variable);
      }

      return childFunction;
   }

   var child = parentFunction();
   child();

parentFunction returns its internal function, and the code at the bottom 
calls this function. Even though parentFunction has finished executing at this 
point, the local environment where variable has the value "local" still exists, 
and childFunction still uses it. This phenomenon is called closure.

-   function makeAddFunction(amount) {
        function add(number) {
                return number + amount;
        }
        return add;
    }

    var addTwo = makeAddFunction(2);
    var addFive = makeAddFunction(5);
    show(addTwo(1) + addFive(1));

Consider this puzzle: By starting from the number 1 and repeatedly either 
adding 5 or multiplying by 3, an infinite amount of new numbers can be 
produced. How would you write a function that, given a number, tries to find 
a sequence of additions and multiplications that produce that number?

For example, the number 13 could be reached by first multiplying 1 by 3, 
and then adding 5 twice. The number 15 can not be reached at all.

-   function findSequence(goal) {
      function find(start, history) {
        if (start == goal)
          return history;
        else if (start > goal)
          return null;
        else
          return find(start + 5, "(" + history + " + 5)") ||
                 find(start * 3, "(" + history + " * 3)");
      }
      return find(1, "1");
    }

    print(findSequence(24));

There is another way to define function values, which more closely 
resembles the way other values are created. When the function keyword 
is used in a place where an expression is expected, it is treated as an 
expression producing a function value. Functions created in this way do not 
have to be given a name (though it is allowed to give them one).

-   var add = function(a, b) {
      return a + b;
    };
    show(add(5, 5));

Note the semicolon after the definition of add. 

This kind of function value is called an anonymous function, because it 
does not have a name. 

- alert("Hello", "Good Evening", "How do you do?", "Goodbye");

The function alert officially only accepts one argument. Yet when you call it 
like this, the computer does not complain at all, but just ignores the other 
arguments.

- show()

You can, apparently, even get away with passing too few arguments. 
When an argument is not passed, its value inside the function is undefined.







First, let me tell you about properties. A lot of JavaScript values have 
other values associated with them. These associations are called properties. 
Every string has a property called length, which refers to a number, the 
amount of characters in that string.

Properties can be accessed in two ways:

-   var text = "purple haze";
    show(text["length"]);
    show(text.length);

The second way is a shorthand for the first, and it only works when the 
name of the property would be a valid variable name ― when it doesn't 
have any spaces or symbols in it and does not start with a digit character.

The values null and undefined do not have any properties. Trying to read 
properties from such a value produces an error. 

The properties of a string value can not be changed. There are quite a few 
more than just length, as we will see, but you are not allowed to add or 
remove any.

This is different with values of the type object. Their main role is to hold 
other values. They have, you could say, their own set of tentacles in the 
form of properties. You are free to modify these, remove them, or add new ones.

-   var cat = {colour: "grey", name: "Spot", size: 46};
    cat.size = 47;
    show(cat.size);
    delete cat.size;
    show(cat.size);
    show(cat);

The keyword delete cuts off properties. Trying to read a non-existent 
property gives the value undefined.

If a property that does not yet exist is set with the = operator, it is 
added to the object.

-   var empty = {};
    empty.notReally = 1000;
    show(empty.notReally);

Properties whose names are not valid variable names have to be quoted when 
creating the object, and approached using brackets:

-   var thing = {"gabba gabba": "hey", "5": 10};
    show(thing["5"]);
    thing["5"] = 20;
    show(thing[2 + 3]);
    delete thing["gabba gabba"];

The operator in can be used to test whether an object has a certain property. 
It produces a boolean.

-   var chineseBox = {};
    /* chineseBox.content contains object chineseBox */
    chineseBox.content = chineseBox;
    show("content" in chineseBox);
    show("content" in chineseBox.content);

Object values, apparently, can change. The types of values discussed in 
chapter 2 are all immutable, it is impossible to change an existing 
value of those types. You can combine them and derive new values from 
them, but when you take a specific string value, the text inside it can not 
change. With objects, on the other hand, the content of a value can be 
modified by changing its properties.

    var object1 = {value: 10 };
    var object2 = object1;
    var object3 = {value: 10 };

    show(object1 == object2 );
    show(object1 == object3 );

object1 and object2 are two variables grasping the same value. 
There is only one actual object, which is why changing object1 also 
changes the value of object2.

JavaScript's == operator, when comparing objects, will only return true if 
both values given to it are the precise same value. Comparing different 
objects with identical contents will give false. This is useful in some 
situations, but impractical in others.


[Still using javascript properties]
        var mailArchive = {0: "Dear nephew, ... (mail number 1 )",
                           1: "(mail number 2 )",
                           2: "(mail number 3 )"};

        /* current in mailArchive returns a bool that
           says whether that number is a property */
        for (var current = 0; current in mailArchive; current++ )
            /** don't forget you can access a property via object["property"] */
            print("Processing e-mail #", current, ": ", mailArchive[current]);

New arrays can be created using brackets ([ and  ]):

    var mailArchive = ["mail one", "mail two", "mail three"];

    for (var current = 0; current < mailArchive.length; current++ )
          print("Processing e-mail #", current, ": ", mailArchive[current]);


 [arrays and properties are basically the same, except that in arrays there is a
 length property and arrays auto generate the key for the value]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          var array_to = [];
          for (var x = 0; x <= y, x++) {
              array_to[x] = y;
          }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    var doh = "Doh";
    print(typeof doh.toUpperCase );
    print(doh.toUpperCase());
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    var mack = [];
    mack.push("Mack");
    mack.push("the");
    mack.push("Knife");
    show(mack.join(" "));
    show(mack.pop());
    show(mack);

The method push, which is associated with arrays, can be used to add 
values to it. It could have been used in the last exercise, as an 
alternative to result[i] = i

Then there is pop, the opposite of push: it takes off and returns the 
last value in the array. join builds a single big string from an 
array of strings. The parameter it is given is pasted between the 
values in the array.

Strings already have a method named split, which is (almost) the 
opposite of the join method of arrays. It splits a string into an 
array, using the string given as its argument to determine in 
which places to cut.

    var words = "Cities of the Interior";
    show(words.split(" "));


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    var array = ["a", "b", "c d"];
    show(array.join(" ").split(" "));

    string.split(x).join(x) always produces the original value, 
    but array.join(x).split(x) does not. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Strings also have a method called slice. It copies out a piece of the 
string, starting from the character at the position given by the first 
argument, and ending before (not including ) the character at the 
position given by the second one.

    show(paragraph.slice(0, 4) == "born");

The method charAt can be used to get a specific character from a string.

charAt will return "" when there is no character at the given 
position, and slice will simply leave out the part of the new 
string that does not exist.

Just like the notation with braces and colons we have already seen, 
new is a way to create object values. Instead of specifying all the 
property names and values, a function is used to build up the object. 
This makes it possible to define a kind of standard procedure for 
creating objects.

    show(new Date() );
    show(new Date(1980, 1, 1) );
    show(new Date(2007, 2, 30, 8, 20, 30) );

As you can see, these objects can store a time of day as well as a 
date. When not given any arguments, an object representing the current 
time and date is created.

    var wallFall = new Date(1989, 10, 9 );
    var gulfWarOne = new Date(1990, 6, 2);
    show(wallFall < gulfWarOne );

Comparing dates with <, >, <=, and >= does exactly what you would 
expect. When a date object is compared to itself with == the result is 
true, which is also good. But when == is used to compare a date object to a 
different, equal date object, we get false.

As mentioned earlier, == will return false when comparing two different 
objects, even if they contain the same properties. This is a bit clumsy 
and error-prone here, since one would expect >= and == to behave in a 
more or less similar way. Testing whether two dates are equal 
can be done like this:

    var wallFall1 = new Date(1989, 10, 9 ),
        wallFall2 = new Date(1989, 10, 9 );
        show(wallFall1.getTime() == wallFall2.getTime());


Whenever a function is called, a special variable named arguments 
is added to the environment in which the function body runs. 
This variable refers to an object that resembles an array. It has a 
property 0 for the first argument, 1 for the second, and so on for 
every argument the function was given. It also has a length property.

This object is not a real array though, it does not have methods like 
push, and it does not automatically update its length property 
when you add something to it. 

Some functions can take any number of arguments, like 
print does. These typically loop over the values in the arguments 
object to do something with them. Others can take optional arguments 
which, when not given by the caller, get some sensible default value.

    function add(number, howmuch ) {
          if (arguments.length < 2 )
            howmuch = 1;
          return number + howmuch;
    }
    show(add(6));
    show(add(6, 4 ));

Most languages will stop you, or at least warn you, when you are 
defining a variable with a name that is already taken. Not JavaScript.

Unfortunately, there is no one comprehensive complete reference for 
JavaScript. This is mostly because its current form is the result of a 
chaotic process of different browsers adding different extensions at 
different times. The ECMA standard document that was mentioned in the 
introduction provides a solid documentation of the basic language, 
but is more or less unreadable. For most things, your best bet 
is the Mozilla Developer Network.


Maybe you already thought of a way to find out what is available in the 
Math object:

    for (var name in Math)
        print(name);

But alas, nothing appears. Similarly, when you do this:

    for (var name in ["Huey", "Dewey", "Loui"] )
          print(name);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    NOTE:
    for (var name in obj)
        print(name);

    /* this will show the properties in object obj */

    for ("c" in obj);
    /* this will give a boolean that says if "c" is a property of obj */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

You only see 0, 1, and 2, not length, or push, or join, 
which are definitely also in there. Apparently, some properties of 
objects are hidden. There is a good reason for this: All objects have a 
few methods, for example toString, which converts the object into some 
kind of relevant string, and you do not want to see those when you 
are, for example, looking for the cats that you stored in the object.

Some properties are read-only, you can get their value but not change 
it. For example, the properties of a string value are all read-only.

Other properties can be 'active'. Changing them causes things to 
happen. For example, lowering the length of an array causes excess 
elements to be discarded:

    var array = ["Heaven", "Earth", "Man"];
    array.length = 2;
    show(array);




- Error Handling Chapter 5

One solution is to make between return a special value, 
such as false or undefined, when it fails.

But most of the time, functions that fail 'silently' are hard to use, 
and even dangerous. What if the code calling between wants to know 
whether everything went well? At the moment, it can not tell, 
except by re-doing all the work that between did and checking the 
result of between with its own result. That is bad. One solution is 
to make between return a special value, such as false or undefined, 
when it fails.

    if (startAt == -1 )
            return undefined;

    if (parenthesized != undefined )
          print("You parenthesized '", parenthesized, "'.");





      function lastElement(array) {
        if (array.length > 0 )
            return array[array.length - 1 ];
        else
            throw "Can not take the last element of an empty array.";

      }

        function lastElementPlusTen(array) {
              return lastElement(array) + 10;

        }

        try {
              print(lastElementPlusTen([]));

        }
        catch (error) {
              print("Something went wrong: ", error);

        }

throw new Error("Fire!");



- Functional Programming Chapter6

Functional programming, which is the subject of this chapter, 
produces abstraction through clever ways of combining functions. A 
programmer armed with a repertoire of fundamental functions and, 
more importantly, the knowledge on how to use them, is much more 
effective than one who starts from scratch. Unfortunately, a 
standard JavaScript environment comes with deplorably few 
essential functions, so we have to write them ourselves or, 
which is often preferable, make use of somebody else's code 


But what if we want to do something else than print? Since 'doing something' 
can be represented as a function, and functions are also values, 
we can pass our action as a function value:

    function forEach(array, action ) {
          for (var i = 0; i < array.length; i++ )
                  action(array[i]);

    }

    forEach(["Wampeter", "Foma", "Granfalloon"], print);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    function sum(numbers) {
          var total = 0;
          forEach(numbers, function (number) {
                  total += number;

                  } );
            return total;

    }
    show(sum([1, 10, 100 ]));

Note that the variable total is visible inside the anonymous function 
because of the lexical scoping rules. Also note that this version is 
hardly shorter than the for loop and requires a rather clunky }); at its 
end ― the brace closes the body of the anonymous function, the parenthesis 
closes the function call to forEach, and the semicolon is needed 
because this call is a statement.

What forEach does is take an algorithm, in this case 'going over an array', 
and abstract it. The 'gaps' in the algorithm, in this case, what to do for 
each of these elements, are filled by functions which are passed to the 
algorithm function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Functions that operate on other functions are called higher-order functions. 
By operating on functions, they can talk about actions on a whole new level. 
The makeAddFunction function from chapter 3 is also a higher-order function. 
Instead of taking a function value as an argument, it produces a new function.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Being able to write what we want to do instead of how we do it means we are 
working at a higher level of abstraction. In practice, this means shorter, 
clearer, and more pleasant code.

Another useful type of higher-order function modifies the function value 
it is given:

    function negate(func) {
        return function(x) {
                return !func(x);
        };

    }
    var isNotNaN = negate(isNaN);
    show(isNotNaN(NaN));

Functions have a method called apply, which is used for situations like 
this. It takes two arguments. The role of the first argument will be 
discussed in chapter 8, for now we just use null there. The second argument 
is an array containing the arguments that the function must be applied to.

    show(Math.min.apply(null, [5, 6 ] ));

    function negate(func) {
        return function() {
                return !func.apply(null, arguments );

        };

    }

Unfortunately, on the Internet Explorer browser a lot of built-in functions, 
such as alert, are not really functions... or something. They report their 
type as "object" when given to the typeof operator, and they do not have an 
apply method. Your own functions do not suffer from this, they are always real 
functions.

    function reduce(combine, base, array ) {
        forEach(array, function (element) {
                base = combine(base, element );

                } );
          return base;

    }

    function add(a, b ) {
          return a + b;

    }

    function sum(numbers) {
          return reduce(add, 0, numbers );

    }

reduce combines an array into a single value by repeatedly using a function that
combines an element of the array with a base value. This is exactly what sum
did, so it can be made shorter by using reduce... except that addition is an
operator and not a function in JavaScript, so we first had to put it into a
function.

The reason reduce takes the function as its first argument instead of its last,
as in forEach, is partly that this is tradition ― other languages do it like
that ― and partly that this allows us to use a particular trick, which will be
discussed at the end of this chapter. It does mean that, when calling reduce,
writing the reducing function as an anonymous function looks a bit weirder,
because now the other arguments follow after the function, and the resemblance
to a normal for block is lost entirely.


One other generally useful 'fundamental algorithm' related to arrays is called
map. It goes over an array, applying a function to every element, just like
forEach. But instead of discarding the values returned by function, it builds up
a new array from these values.


    function map(func, array ) {
          var result = [];
          forEach(array, function (element) {
                  result.push(func(element));

                  } );
            return result;

    }

    show(map(Math.round, [0.01, 2, 9.89, Math.PI] ));

31% Chapter6 [Unfinished]

- Searching Chapter7

- OOP Chapter8

As the name suggests, object-oriented programming is related to objects. So far,
we have used objects as loose aggregations of values, adding and altering their
properties whenever we saw fit. In an object-oriented approach, objects are
viewed as little worlds of their own, and the outside world may touch them only
through a limited and well-defined interface, a number of specific methods and
properties.


One way to give an object methods is to simply attach function values to it.

    var rabbit = {};
    rabbit.speak = function(line) {
          print("The rabbit says '", line, "'");

    };

    rabbit.speak("Well, now you're asking me.");

In most cases, the method will need to know who it should act on. For example,
if there are different rabbits, the speak method must indicate which rabbit is
speaking. For this purpose, there is a special variable called this, which
is always present when a function is called, and which points at the
relevant object when the function is called as a method. A function is
called as a method when it is looked up as a property, and immediately
called, as in object.method().

    function speak(line) {
          print("The ", this.adjective, " rabbit says '", line, "'");

    }
    var whiteRabbit = {adjective: "white", speak: speak };
    var fatRabbit = {adjective: "fat", speak: speak };

    whiteRabbit.speak("Oh my ears and whiskers, how late it's getting!");
    fatRabbit.speak("I could sure use a carrot right now.");

I can now clarify the mysterious first argument to the apply method, for which
we always used null in chapter 6. This argument can be used to specify the
object that the function must be applied to. For non-method functions, this is
irrelevant, hence the null.

speak.apply(fatRabbit, ["Yum."] );

Functions also have a call method, which is similar to apply, but you can give
the arguments for the function separately instead of as an array:

speak.call(fatRabbit, "Burp." );

The new keyword provides a convenient way of creating new objects. When a
function is called with the word new in front of it, its this variable will
point at a new object, which it will automatically return (unless it explicitly
returns something else). Functions used to create new objects like this are
called constructors. Here is a constructor for rabbits:

    function Rabbit(adjective) {
          this.adjective = adjective;
          this.speak = function(line) {
                  print("The ", this.adjective, " rabbit says '", line, "'");
          };

    }

    var killerRabbit = new Rabbit("killer");
    killerRabbit.speak("GRAAAAAAAAAH!");

It is a convention, among JavaScript programmers, to start the names of
constructors with a capital letter. This makes it easy to distinguish them from
other functions.

Why is the new keyword even necessary? After all, we could have simply written
this:

    function makeRabbit(adjective) {
        return {
                adjective: adjective,
                    speak: function(line) {/*etc*/}
        };

    }

    var blackRabbit = makeRabbit("black");

But that is not entirely the same. new does a few things behind the scenes. For
one thing, our killerRabbit has a property called constructor, which points at
the Rabbit function that created it. blackRabbit also has such a property, but
it points at the Object function.

Where did the constructor property come from? It is part of the prototype of a
rabbit. Prototypes are a powerful, if somewhat confusing, part of the way
JavaScript objects work. Every object is based on a prototype, which gives it a
set of inherent properties. The simple objects we have used so far are based on
the most basic prototype, which is associated with the Object constructor. In
fact, typing {} is equivalent to typing new Object().

toString is a method that is part of the Object prototype. This means that all
simple objects have a toString method, which converts them to a string. Our
rabbit objects are based on the prototype associated with the Rabbit
constructor. You can use a constructor's prototype property to get access to,
well, their prototype:


    show(Rabbit.prototype);
    show(Rabbit.prototype.constructor);

Every function automatically gets a prototype property, whose constructor
property points back at the function. Because the rabbit prototype is itself an
object, it is based on the Object prototype, and shares its toString method.

    show(killerRabbit.toString == simpleObject.toString );

Even though objects seem to share the properties of their prototype, this
sharing is one-way. The properties of the prototype influence the object based
on it, but the properties of this object never change the prototype.

This does mean that the prototype can be used at any time to add new properties
and methods to all objects based on it. For example, it might become necessary
for our rabbits to dance.

    Rabbit.prototype.dance = function() {
          print("The ", this.adjective, " rabbit dances a jig.");

    };

    killerRabbit.dance();

And, as you might have guessed, the prototypical rabbit is the perfect place for
values that all rabbits have in common, such as the speak method. Here is a new
approach to the Rabbit constructor:

    function Rabbit(adjective) {
          this.adjective = adjective;

    }
    Rabbit.prototype.speak = function(line) {
          print("The ", this.adjective, " rabbit says '", line, "'");

    };

    var hazelRabbit = new Rabbit("hazel");
    hazelRabbit.speak("Good Frith!");

This is problematic. A related problem is that it can often be practical to
extend the prototypes of standard constructors such as Object and Array with new
useful functions. For example, we could give all objects a method called
properties, which returns an array with the names of the (non-hidden) properties
that the object has:

    Object.prototype.properties = function() {
          var result = [];
          for (var property in this )
                result.push(property);
          return result;
    };

    var test = {x: 10, y: 3 };
    show(test.properties());

And that immediately shows the problem. Now that the Object prototype has a
property called properties, looping over the properties of any object, using for
and in, will also give us that shared property, which is generally not what we
want. We are interested only in the properties that the object itself has.


Fortunately, there is a way to find out whether a property belongs to the object
itself or to one of its prototypes. Unfortunately, it does make looping over the
properties of an object a bit clumsier. Every object has a method called
hasOwnProperty, which tells us whether the object has a property with a given
name. Using this, we could rewrite our properties method like this:

    Object.prototype.properties = function() {
          var result = [];
          for (var property in this ) {
                  if (this.hasOwnProperty(property))
                            result.push(property);
          }
            return result;

    };
pgpgpg
    var test = {"Fat Igor": true, "Fireball": true};
    show(test.properties());


And of course, we can abstract that into a higher-order function. Note that the
action function is called with both the name of the property and the value it
has in the object.

    function forEachIn(object, action ) {
        for (var property in object ) {
            if (object.hasOwnProperty(property))
                action(property, object[property] );
        }

    }

    var chimera = {head: "lion", body: "goat", tail: "snake" };
    forEachIn(chimera, function(name, value ) {
            print("The ", name, " of a ", value, ".");
            } );


# If you try to define a property with name hasOwnProperty:
# Exception: TypeError: this.hasOwnProperty is not a function
# in function ()
# so if you define a property having name hasOwnProperty,
# then you are redifining function hasOwnProperty to hold value true,
# and not a function

But, what if we find a cat named hasOwnProperty? (You never know. ) It will be
stored in the object, and the next time we want to go over the collection of
cats, calling object.hasOwnProperty will fail, because that property no longer
points at a function value. This can be solved by doing something even uglier:

    function forEachIn(object, action ) {
        for (var property in object ) {
                if (Object.prototype.hasOwnProperty.call(object, property ))
                          action(property, object[property] );
        }

    }

    var test = {name: "Mordecai", hasOwnProperty: "Uh-oh" };
    forEachIn(test, function(name, value ) {
          print("Property ", name, " = ", value);
            } );

hasOwnProperty can also be used in those situations where we have been using the
in operator to see whether an object has a specific property. There is one more
catch, however. We saw in chapter 4 that some properties, such as toString, are
'hidden', and do not show up when going over properties with for/in. It turns
out that browsers in the Gecko family (Firefox, most importantly ) give every
object a hidden property named __proto__, which points to the prototype of that
object. hasOwnProperty will return true for this one, even though the program
did not explicitly add it. Having access to the prototype of an object can be
very convenient, but making it a property like that was not a very good idea.
Still, Firefox is a widely used browser, so when you write a program for the web
you have to be careful with this. There is a method propertyIsEnumerable, which
returns false for hidden properties, and which can be used to filter out strange
things like __proto__. An expression such as this one can be used to reliably
work around this:

    var object = {foo: "bar" };
    show(Object.prototype.hasOwnProperty.call(object, "foo" ) &&
         Object.prototype.propertyIsEnumerable.call(object, "foo" ));


Writing the above expression every time you need to check whether a property is
present in an object is unworkable. We could put it into a function, but an even
better approach is to write a constructor and a prototype specifically for
situations like this, where we want to approach an object as just a set of
properties. Because you can use it to look things up by name, we will call it a
Dictionary.

    function Dictionary(startValues) {
          this.values = startValues || {};

    }
    Dictionary.prototype.store = function(name, value ) {
          this.values[name] = value;

    };
    Dictionary.prototype.lookup = function(name) {
          return this.values[name];

    };
    Dictionary.prototype.contains = function(name) {
          return Object.prototype.hasOwnProperty.call(this.values, name ) &&
              Object.prototype.propertyIsEnumerable.call(this.values, name );

    };
    Dictionary.prototype.each = function(action) {
          forEachIn(this.values, action );

    };

    var colours = new Dictionary({Grover: "blue",
                                  Elmo: "orange",
                                  Bert: "yellow"});

    show(colours.contains("Grover"));
    show(colours.contains("constructor"));
    colours.each(function(name, colour ) {
          print(name, " is ", colour );

            });

Now the whole mess related to approaching objects as plain sets of properties
has been 'encapsulated' in a convenient interface: one constructor and four
methods. Note that the values property of a Dictionary object is not part of
this interface, it is an internal detail, and when you are using Dictionary
objects you do not need to directly use it.

[22% Chapter 8]

The distinction between the external interface of an object and its internal
details is important for two reasons. Firstly, having a small, clearly described
interface makes an object easier to use. You only have to keep the interface in
mind, and do not have to worry about the rest unless you are changing the object
itself.

In this chapter we are going to build a virtual terrarium, a tank with insects
moving around in it. There will be some objects involved (this is, after all,
the chapter on object-oriented programming ). We will take a rather simple
approach, and make the terrarium a two-dimensional grid, like the second map in
chapter 7. On this grid there are a number of bugs. When the terrarium is
active, all the bugs get a chance to take an action, such as moving, every half
second.

Thus, we chop both time and space into units with a fixed size ― squares for
space, half seconds for time. This usually makes things easier to model in a
program, but of course has the drawback of being wildly inaccurate. Fortunately,
this terrarium-simulator is not required to be accurate in any way, so we can
get away with it.

var thePlan =
  ["############################",
   "#      #    #      o      ##",
   "#                          #",
   "#          #####           #",
   "##         #   #    ##     #",
   "###           ##     #     #",
   "#           ###      #     #",
   "#   ####                   #",
   "#   ##       o             #",
   "# o  #         o       ### #",
   "#    #                     #",
   "############################"];

The "#" characters are used to represent the walls of the terrarium (and the
ornamental rocks lying in it ), the "o"s represent bugs, and the spaces are, as
you might have guessed, empty space.

Such a plan-array can be used to create a terrarium-object. This object keeps
track of the shape and content of the terrarium, and lets the bugs inside move.
It has four methods: Firstly toString, which converts the terrarium back to a
string similar to the plan it was based on, so that you can see what is going on
inside it. Then there is step, which allows all the bugs in the terrarium to
move one step, if they so desire. And finally, there are start and stop, which
control whether the terrarium is 'running'. When it is running, step is
automatically called every half second, so the bugs keep moving.

I said above that the terrarium object will be responsible for storing its
contents and for letting the bugs inside it move. Firstly, note that it lets
them move, it doesn't make them move. The bugs themselves will also be objects,
and these objects are responsible for deciding what they want to do. The
terrarium merely provides the infrastructure that asks them what to do every
half second, and if they decide to move, it makes sure this happens.

Storing the grid on which the content of the terrarium is kept can get quite
complex. It has to define some kind of representation, ways to access this
representation, a way to initialise the grid from a 'plan' array, a way to write
the content of the grid to a string for the toString method, and the movement of
the bugs on the grid. It would be nice if part of this could be moved into
another object, so that the terrarium object itself doesn't get too big and
complex.


Whenever you find yourself about to mix data representation and problem-specific
code in one object, it is a good idea to try and put the data representation
code into a separate type of object. In this case, we need to represent a grid
of values, so I wrote a Grid type, which supports the operations that the
terrarium will need.


To store the values on the grid, there are two options. One can use an array of
arrays, like this:

    var grid = [["0,0", "1,0", "2,0"],
                ["0,1", "1,1", "2,1"]];

    show(grid[1][2]);

Or the values can all be put into a single array. In this case, the element at
x,y can be found by getting the element at position x + y * width in the array,
where width is the width of the grid.

    var grid = ["0,0", "1,0", "2,0",
                "0,1", "1,1", "2,1"];
    show(grid[2 + 1 * 3 ]);

I chose the second representation, because it makes it much easier to initialise
the array. new Array(x) produces a new array of length x, filled with undefined
values.

    function Grid(width, height ) {
        this.width = width;
        this.height = height;
        this.cells = new Array(width * height );

    }
    Grid.prototype.valueAt = function(point) {
          return this.cells[point.y * this.width + point.x ];

    };
    Grid.prototype.setValueAt = function(point, value ) {
          this.cells[point.y * this.width + point.x ] = value;

    };
    Grid.prototype.isInside = function(point) {
          return point.x >= 0 && point.y >= 0 &&
                   point.x < this.width && point.y < this.height;

    };
    Grid.prototype.moveValue = function(from, to ) {
          this.setValueAt(to, this.valueAt(from) );
            this.setValueAt(from, undefined );

    };


    var testGrid = new Grid(3, 2 );
    testGrid.setValueAt(new Point(1, 0 ), "#" );
    testGrid.setValueAt(new Point(1, 1 ), "o" );
    testGrid.each(function(point, value ) {
          print(point.x, ",", point.y, ": ", value );

            });

Before we can start to write a Terrarium constructor, we will have to get a bit
more specific about these 'bug objects' that will be living inside it. Earlier,
I mentioned that the terrarium will ask the bugs what action they want to take.
This will work as follows: Each bug object has an act method which, when called,
returns an 'action'. An action is an object with a type property, which names
the type of action the bug wants to take, for example "move". For most actions,
the action also contains extra information, such as the direction the bug wants
to go.

Bugs are terribly myopic, they can only see the squares directly around them on
the grid. But these they can use to base their action on. When the act method is
called, it is given an object with information about the surroundings of the bug
in question. For each of the eight directions, it contains a property. The
property indicating what is above the bug is called "n", for North, the one
indicating what is above and to the right "ne", for North-East, and so on. To
look up the direction these names refer to, the following dictionary object is
useful:

    var directions = new Dictionary(
      {"n":  new Point( 0, -1),
       "ne": new Point( 1, -1),
       "e":  new Point( 1,  0),
       "se": new Point( 1,  1),
       "s":  new Point( 0,  1),
       "sw": new Point(-1,  1),
       "w":  new Point(-1,  0),
       "nw": new Point(-1, -1)});

    show(new Point(4, 4).add(directions.lookup("se")));


When a bug decides to move, he indicates in which direction he wants to go by
giving the resulting action object a direction property that names one of these
directions. We can make a simple, stupid bug that always just goes south,
'towards the light', like this:


    function StupidBug() {};
    StupidBug.prototype.act = function(surroundings) {
          return {type: "move", direction: "s" };

    };

Now we can start on the Terrarium object type itself. First, its constructor,
which takes a plan (an array of strings ) as argument, and initialises its grid.

    var wall = {};

    function Terrarium(plan) {
      var grid = new Grid(plan[0].length, plan.length);
      for (var y = 0; y < plan.length; y++) {
        var line = plan[y];
        for (var x = 0; x < line.length; x++) {
          grid.setValueAt(new Point(x, y),
                          elementFromCharacter(line.charAt(x)));
        }
      }
      this.grid = grid;
    }

    function elementFromCharacter(character) {
      if (character == " ")
        return undefined;
      else if (character == "#")
        return wall;
      else if (character == "o")
        return new StupidBug();
    }


wall is an object that is used to mark the location of walls on the grid. Like a
real wall, it doesn't do much, it just sits there and takes up space.
[Continued]


- Modularity Chapter9

This chapter deals with the process of organising programs. In small programs,
organisation rarely becomes a problem. As a program grows, however, it can reach
a size where its structure and interpretation become hard to keep track of.
Easily enough, such a program starts to look like a bowl of spaghetti, an
amorphous mass in which everything seems to be connected to everything else.

When structuring a program, we do two things. We separate it into smaller parts,
called modules, each of which has a specific role, and we specify the relations
between these parts.

When a module depends on another module, it uses functions or variables from
that module, and will only work when this module is loaded.

Most modern programming languages have some kind of module system built in. Not
JavaScript. Once again, we have to invent something ourselves. The most obvious
way to start is to put every module in a different file. This makes it clear
which code belongs to which module.

Browsers load JavaScript files when they find a <script> tag with an src
attribute in the HTML of the web-page. The extension .js is usually used for
files containing JavaScript code. On the console, a shortcut for loading files
is provided by the load function.

    load("FunctionalTools.js");

In some cases, giving load commands in the wrong order will result in errors. If
a module tries to create a Dictionary object, but the Dictionary module has not
been loaded yet, it will be unable to find the constructor, and will fail.

One would imagine this to be easy to solve. Just put some calls to load at the
top of the file for a module, to load all the modules it depends on.
Unfortunately, because of the way browsers work, calling load does not
immediately cause the given file to be loaded. The file will be loaded after the
current file has finished executing. Which is too late, usually.

In most cases, the practical solution is to just manage dependencies by hand:
Put the script tags in your HTML documents in the right order.

There are two ways to (partially) automate dependency management. The first is
to keep a separate file with information about the dependencies between modules.
This can be loaded first, and used to determine the order in which to load the
files. The second way is to not use a script tag (load internally creates and
adds such a tag ), but to fetch the content of the file directly (see chapter 14
), and then use the eval function to execute it. This makes script loading
instantaneous, and thus easier to deal with.


eval, short for 'evaluate', is an interesting function. You give it a string
value, and it will execute the content of the string as JavaScript code.


    eval("print(\"I am a string inside a string!\");");

You can imagine that eval can be used to do some interesting things. Code can
build new code, and run it. In most cases, however, problems that can be solved
with creative uses of eval can also be solved with creative uses of anonymous
functions, and the latter is less likely to cause strange problems.

When eval is called inside a function, all new variables will become local to
that function. Thus, when a variation of the load would use eval internally,
loading the Dictionary module would create a Dictionary constructor inside of
the load function, which would be lost as soon as the function returned. There
are ways to work around this, but they are rather clumsy.


Let us quickly go over the first variant of dependency management. It requires a
special file for dependency information, which could look something like this:


    var dependencies =
      {"ObjectTools.js": ["FunctionalTools.js"],
       "Dictionary.js":  ["ObjectTools.js"],
       "TestModule.js":  ["FunctionalTools.js", "Dictionary.js"]};


The dependencies object contains a property for each file that depends on other
files. The values of the properties are arrays of file names. Note that we could
not use a Dictionary object here, because we can not be sure that the Dictionary
module has been loaded yet. Because all the properties in this object will end
in ".js", they are unlikely to interfere with hidden properties like __proto__
or hasOwnProperty, and a regular object will work fine.


The dependency manager must do two things. Firstly it must make sure that files
are loaded in the correct order, by loading a file's dependencies before the
file itself. And secondly, it must make sure that no file is loaded twice.
Loading the same file twice might cause problems, and is definitely a waste of
time.

    var loadedFiles = {};

    function require(file) {
        if (dependencies[file]) {
                var files = dependencies[file];
                    for (var i = 0; i < files.length; i++ )
                              require(files[i]);
        }
        if (!loadedFiles[file]) {
                loadedFiles[file] = true;
                    load(file);
        }
    }

The require function can now be used to load a file and all its dependencies.
Note how it recursively calls itself to take care of dependencies (and possible
dependencies of that dependency).

    require("TestModule.js");

Building a program as a set of nice, small modules often means the program will
use a lot of different files. When programming for the web, having lots of small
JavaScript files on a page tends to make the page slower to load. This does not
have to be a problem though. You can write and test your program as a number of
small files, and put them all into a single big file when 'publishing' the
program to the web.


Just like an object type, a module has an interface. In simple
collection-of-functions modules such as FunctionalTools, the interface usually
consists of all the functions that are defined in the module.

In other cases, the interface of the module is only a small part of the
functions defined inside it. For example, our manuscript-to-HTML system from
chapter 6 only needs an interface of a single function, renderFile. (The
sub-system for building HTML would be a separate module. )


For modules which only define a single type of object, such as Dictionary, the
object's interface is the same as the module's interface.


In JavaScript, 'top-level' variables all live together in a single place. In
browsers, this place is an object that can be found under the name window. The
name is somewhat odd, environment or top would have made more sense, but since
browsers associate a JavaScript environment with a window (or 'frame' ), someone
decided that window was a logical name.




        show(window);
        show(window.print == print );
        show(window.window.window.window.window);


As the third line shows, the name window is merely a property of this
environment object, pointing at itself.




When much code is loaded into an environment, it will use many top-level
variable names. Once there is more code than you can really keep track of, it
becomes very easy to accidentally use a name that was already used for something
else. This will break the code that used the original value. The proliferation
of top-level variables is called name-space pollution, and it can be a
rather severe problem in JavaScript ― the language will not warn you when
you redefine an existing variable.

There is no way to get rid of this problem entirely, but it can be greatly
reduced by taking care to cause as little pollution as possible. For one thing,
modules should not use top-level variables for values that are not part of their
external interface.






Not being able to define any internal functions and variables at all in your
modules is, of course, not very practical. Fortunately, there is a trick to get
around this. We write all the code for the module inside a function, and then
finally add the variables that are part of the module's interface to the window
object. Because they were created in the same parent function, all the functions
of the module can see each other, but code outside of the module can not.






    function buildMonthNameModule() {
          var names = ["January", "February", "March", "April",
                         "May", "June", "July", "August", "September",
                                        "October", "November", "December"];
          function getMonthName(number) {
                  return names[number];
          }
          function getMonthNumber(name) {
              for (var number = 0; number < names.length; number++ ) {
                        if (names[number] == name)
                                    return number;
              }
          }

            window.getMonthName = getMonthName;
              window.getMonthNumber = getMonthNumber;

    }


But note that buildMonthNameModule is still a top-level variable that is not
part of the module's interface. Also, we have to repeat the names of the
interface functions three times. Ugh.

The first problem can be solved by making the module function anonymous, and
calling it directly. To do this, we have to add a pair of parentheses around the
function value, or JavaScript will think it is a normal function definition,
which can not be called directly.


The second problem can be solved with a helper function, provide, which can be
given an object containing the values that must be exported into the window
object.




    function provide(values) {
        forEachIn(values, function(name, value ) {
                window[name] = value;
                } );
    }

    (function() {
          var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
                         "Thursday", "Friday", "Saturday"];
          provide({
            getDayName: function(number) {
              return names[number];
           },
           getDayNumber: function(name) {
            for (var number = 0; number < names.length; number++ ) {
                    if (names[number] == name)
                                  return number;
                    }
            }
           });

     })();

     show(getDayNumber("Wednesday"));


I do not recommend writing modules like this right from the start. While you are
still working on a piece of code, it is easier to just use the simple approach
we have used so far, and put everything at top level. That way, you can inspect
the module's internal values in your browser, and test them out. Once a module
is more or less finished, it is not difficult to wrap it in a function.


There are cases where a module will export so many variables that it is a bad
idea to put them all into the top-level environment. In cases like this, you can
do what the standard Math object does, and represent the module as a single
object whose properties are the functions and values it exports. For
example...


var HTML = {
tag: function(name, content, properties ) {
        return {name: name, properties: properties, content: content };
     },
link: function(target, text ) {
        return HTML.tag("a", [text], {href: target });
      }
        /* ... many more HTML-producing functions ... */

};


When you need the content of such a module so often that it becomes cumbersome
to constantly type HTML, you can always move it into the top-level environment
using provide.


    provide(HTML);
    show(
    link("http://download.oracle.com/docs/cd/E19957-01/816-6408-10/object.htm",
              "This is how objects work."));

You can even combine the function and object approaches, by putting the internal
variables of the module inside a function, and having this function return an
object containing its external interface.


When adding methods to standard prototypes, such as those of Array and Object a
similar problem to name-space pollution occurs. If two modules decide to add a
map method to Array.prototype, you might have a problem. If these two versions
of map have the precise same effect, things will continue to work, but only by
sheer luck.




Designing an interface for a module or an object type is one of the subtler
aspects of programming. On the one hand, you do not want to expose too many
details. They will only get in the way when using the module. On the other hand,
you do not want to be too simple and general, because that might make it
impossible to use the module in complex or specialised situations.


Sometimes the solution is to provide two interfaces, a detailed 'low-level' one
for complicated things, and a simple 'high-level' one for straightforward
situations. The second one can usually be built very easily using the tools
provided by the first one.


In other cases, you just have to find the right idea around which to base your
interface. Compare this to the various approaches to inheritance we saw in
chapter 8. By making prototypes the central concept, rather than constructors,
we managed to make some things considerably more straightforward.


The best way to learn the value of good interface design is, unfortunately, to
use bad interfaces. Once you get fed up with them, you'll figure out a way to
improve them, and learn a lot in the process. Try not to assume that a lousy
interface is 'just the way it is'. Fix it, or wrap it in a new interface that is
better (we will see an example of this in chapter 12 ).



There are functions which require a lot of arguments. Sometimes this means they
are just badly designed, and can easily be remedied by splitting them into a few
more modest functions. But in other cases, there is no way around it. Typically,
some of these arguments have a sensible 'default' value. We could, for example,
write yet another extended version of range.




    function range(start, end, stepSize, length ) {
          if (stepSize == undefined )
                  stepSize = 1;
                    if (end == undefined )
                            end = start + stepSize * (length - 1 );

                              var result = [];
                                for (; start <= end; start += stepSize )
                                        result.push(start);
                                          return result;

    }

    show(range(0, undefined, 4, 5));

It can get hard to remember which argument goes where, not to mention the
annoyance of having to pass undefined as a second argument when a length
argument is used. We can make passing arguments to this function more
comprehensive by wrapping them in an object.



    function defaultTo(object, values ) {
        forEachIn(values, function(name, value ) {
                if (!object.hasOwnProperty(name))
                          object[name] = value;
                } );

    }

    function range(args) {
          defaultTo(args, {start: 0, stepSize: 1 } );
            if (args.end == undefined )
                    args.end = args.start + args.stepSize * (args.length - 1 );

                      var result = [];
                        for (; args.start <= args.end; args.start += args.stepSize )
                                result.push(args.start);
                                  return result;

    }

    show(range({stepSize: 4, length: 5 }));


The defaultTo function is useful for adding default values to an object. It
copies the properties of its second argument into its first argument, skipping
those that already have a value.


A module or group of modules that can be useful in more than one program is
usually called a library. For many programming languages, there is a huge set of
quality libraries available. This means programmers do not have to start from
scratch all the time, which can make them a lot more productive. For JavaScript,
unfortunately, the amount of available libraries is not very large.


But recently this seems to be improving. There are a number of good libraries
with 'basic' tools, things like map and clone. Other languages tend to provide
such obviously useful things as built-in standard features, but with JavaScript
you'll have to either build a collection of them for yourself or use a library.
Using a library is recommended: It is less work, and the code in a library has
usually been tested more thoroughly than the things you wrote yourself.



Covering these basics, there are (among others ) the 'lightweight' libraries
prototype, mootools, jQuery, and MochiKit. There are also some larger
'frameworks' available, which do a lot more than just provide a set of basic
tools. YUI (by Yahoo ), and Dojo seem to be the most popular ones in that genre.
All of these can be downloaded and used free of charge. My personal favourite is
MochiKit, but this is mostly a matter of taste. When you get serious about
JavaScript programming, it is a good idea to quickly glance through the
documentation of each of these, to get a general idea about the way they work
and the things they provide.




The fact that a basic toolkit is almost indispensable for any non-trivial
JavaScript programs, combined with the fact that there are so many different
toolkits, causes a bit of a dilemma for library writers. You either have to make
your library depend on one of the toolkits, or write the basic tools yourself
and include them with the library. The first option makes the library hard to
use for people who are using a different toolkit, and the second option adds a
lot of non-essential code to the library. This dilemma might be one of the
reasons why there are relatively few good, widely used JavaScript libraries. It
is possible that, in the future, new versions of ECMAScript and changes in
browsers will make toolkits less necessary, and thus (partially) solve this
problem.



- Regular Expresssions Chapter10
